/*
 * filecontrol.cpp
 *
 * Copyright 2020  <hello@digitalwb.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 *
 *
 */

#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <string>
#include "global.h"
#include "util.h"

using namespace std;

static string myEquipmentsFileName = "myEquipments.txt";
static string scanEquipmentsFileName = "scanEquipments.txt";
static string newDevicesFileName = "newEquipments.txt";

extern users_structure myEquipments[MAXREGISTERS];
extern arpscan_structure scanEquipments[MAXREGISTERS];
extern newDevices_structure newDevices[MAXNEWDEVICES];


/*
*
* name: myEquipmentsFileToStructure
* @param
* use users_structure
* open or create a new file myEquipments.txt
* myEquipments.txt -> should have the following structure:
* <int id>tab<string Owner equipment>tab<string model or brand>tab<string mac address>tab<string date on the format - 2020-04-19|17:19>
* @return
* reads the content of the file to users_structure
*/
int myEquipmentsFileToStructure() {





    //ofstream: Stream class to write on files
    //ifstream: Stream class to read from files
    //fstream: Stream class to both read and write from/to files.
    fstream myEquipmentsFile;
    myEquipmentsFile.open(myEquipmentsFileName, std::fstream::in | std::fstream::out | std::fstream::app);

    //if file doesnt exist
    if (!myEquipmentsFile) {
        myEquipmentsFile.open(myEquipmentsFileName, std::fstream::in | std::fstream::out | std::fstream::trunc);
    }

    int i=0;
    string line;

    while (getline(myEquipmentsFile,line)) { //get line by line of the text file
        std::string field;
        std::vector<std::string> separated_fields;
        std::istringstream iss_line(line);
        while (std::getline(iss_line, field, '\t')) { //Split line with '\t' character
            separated_fields.push_back(field); //Vector containing each field, id, name, model, mac and lastAccess
        }

        myEquipments[i].id = separated_fields[0];
        myEquipments[i].name = separated_fields[1];
        myEquipments[i].model = separated_fields[2];
        myEquipments[i].mac = separated_fields[3];
        myEquipments[i].lastAccess = separated_fields[4];

        //print for test purpose
        /*
        std::cout << "myEquipments[i].id " << myEquipments[i].id << "\n";
        std::cout << "myEquipments[i].name " << myEquipments[i].name << "\n";
        std::cout << "myEquipments[i].model " << myEquipments[i].model << "\n";
        std::cout << "myEquipments[i].mac " << myEquipments[i].mac << "\n";
        std::cout << "myEquipments[i].lastAccess " << myEquipments[i].lastAccess << "\n";
        */

        i++;
    }
    myEquipmentsFile.close();
    return 0;
}

/*
 *
 * name: scanEquipmentsFileToStructure
 * @param
 * uses arpscan_structure
 * reads the content from scanEquipments.txt generated by arp-scan
 * scanEquiments.txt -> it saves the result from network scan on the following format:
 * <ip>tab<mac>tab<brand if found>
 * @return
 * reads from the file to the structure all the devices found
 */
int scanEquipmentsFileToStructure() {

    //ofstream: Stream class to write on files
    //ifstream: Stream class to read from files
    //fstream: Stream class to both read and write from/to files.
    ifstream scanEquipmentsFile;
    scanEquipmentsFile.open(scanEquipmentsFileName);


    //if there is a problem openning or creating the file
    if (!scanEquipmentsFile) {
        cout << "\nError opening file: " << scanEquipmentsFileName << endl;
        exit(1);
    }

    int i=0;
    string line;

    while (getline(scanEquipmentsFile,line)) {
        std::string field;
        std::vector<std::string> separated_fields;
        std::istringstream iss_line(line);
        while (std::getline(iss_line, field, '\t')) { //Split line on the '\t' character
            separated_fields.push_back(field); //Vector containing each field, i.e. ip, mac and macVendor
        }
        scanEquipments[i].ip = separated_fields[0];
        scanEquipments[i].mac = separated_fields[1];
        scanEquipments[i].macVendor = separated_fields[2];
        i++;
    }
    scanEquipmentsFile.close();
    return 0;
}

/*
 *
 * name: saveStructureToMyEquipmentsFile
 * @param
 * uses users_structure
 * @return
 * save the users_structure to myEquipments.txt
 */
int saveStructureToMyEquipmentsFile() {
    //ofstream: Stream class to write on files
    //ifstream: Stream class to read from files
    //fstream: Stream class to both read and write from/to files.
    ofstream myEquipmentsFile;
    myEquipmentsFile.open(myEquipmentsFileName);

    //if doesnt exist gives an error
    if (!myEquipmentsFile) {
        cout << "\n Error file not found!" << scanEquipmentsFileName << endl;
        exit(1);
    }

    //save to file the new data
    int i;
    for (i =0 ; i<MAXREGISTERS; i++)
    {
        if(myEquipments[i].id.compare("\0")!=0) {

            //cout << i << " " << myEquipments[i].id << "comp " << myEquipments[i].id.compare("\0") << endl;

            myEquipmentsFile << myEquipments[i].id << "\t";
            myEquipmentsFile << myEquipments[i].name << "\t";
            myEquipmentsFile << myEquipments[i].model << "\t";
            myEquipmentsFile << myEquipments[i].mac << "\t";
            myEquipmentsFile << myEquipments[i].lastAccess << "\n";
        }
    }

    myEquipmentsFile.close();
    return 0;
}

/*
 *
 * name: newDevicesFileToStructure
 * @param
 * uses newDevices_structure
 * opens or create file newEquipments.txt
 * newEquipments.txt -> it saves the new diveces found on the following format:
 * <ip>tab<mac>tab<brand if found>tab<number of times found on the network>tab<date of the first time found>tab<date of the last time found>
 * @return
 * reads data fom newEquipments.txt to newDevices_structure
 *
 */
int newDevicesFileToStructure() {

    //ofstream: Stream class to write on files
    //ifstream: Stream class to read from files
    //fstream: Stream class to both read and write from/to files.
    fstream newDevicesFile;
    newDevicesFile.open(newDevicesFileName, std::fstream::in | std::fstream::out | std::fstream::app);

    //if file doesnt exist
    if (!newDevicesFile) {
        newDevicesFile.open(newDevicesFileName, std::fstream::in | std::fstream::out | std::fstream::trunc);
    }

    int i=0;
    string line;

    while (getline(newDevicesFile,line)) { //get line by line of the text file
        std::string field;
        std::vector<std::string> separated_fields;
        std::istringstream iss_line(line);
        while (std::getline(iss_line, field, '\t')) { //Split line with '\t' character
            separated_fields.push_back(field); //Vector containing each field, id, name, model, mac and lastAccess
        }

        newDevices[i].ip = separated_fields[0];
        newDevices[i].mac = separated_fields[1];
        newDevices[i].macVendor = separated_fields[2];

        stringstream ss(separated_fields[3]); // object from the class stringstream
        int convertInt;
        ss >> convertInt;
        newDevices[i].timesSeen = convertInt;

        newDevices[i].firstSeenDate = separated_fields[4];
        newDevices[i].lastSeenDate = separated_fields[5];

        //print for test purpose
        /*
        std::cout << "myEquipments[i].id " << myEquipments[i].id << "\n";
        std::cout << "myEquipments[i].name " << myEquipments[i].name << "\n";
        std::cout << "myEquipments[i].model " << myEquipments[i].model << "\n";
        std::cout << "myEquipments[i].mac " << myEquipments[i].mac << "\n";
        std::cout << "myEquipments[i].lastAccess " << myEquipments[i].lastAccess << "\n";
        */

        i++;
    }
    newDevicesFile.close();
    return 0;
}


/*
 * 
 * name: saveStructureToNewDevicesFile
 * @param
 * uses newDevices_structure
 * opens file newEquipments.txt
 * @return
 * save the newDevices_structure to file newEquipments.txt
 */
int saveStructureToNewDevicesFile() {

    //ofstream: Stream class to write on files
    //ifstream: Stream class to read from files
    //fstream: Stream class to both read and write from/to files.
    ofstream newDevicesFile;
    newDevicesFile.open(newDevicesFileName);

    //if doesnt exist gives an error
    if (!newDevicesFile) {
        cout << "\n Error file not found!" << newDevicesFileName << endl;
        exit(1);
    }

    //save to file
    int i;
    for (i =0 ; i<MAXNEWDEVICES; i++) {
        if(newDevices[i].ip.compare("\0")!=0) {
            //cout << i << " " << newDevices[i].ip << "comp " << newDevices[i].ip.compare("\0") << endl;
            newDevicesFile << newDevices[i].ip << "\t";
            newDevicesFile << newDevices[i].mac << "\t";
            newDevicesFile << newDevices[i].macVendor << "\t";
            newDevicesFile << newDevices[i].timesSeen << "\t";
            newDevicesFile << newDevices[i].firstSeenDate << "\t";
            newDevicesFile << newDevices[i].lastSeenDate << "\n";
        }
    }

    newDevicesFile.close();
    return 0;
}

